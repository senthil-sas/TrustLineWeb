{"remainingRequest":"/home/stoneage/vueJs projects/trustLineTradeVuex/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/stoneage/vueJs projects/trustLineTradeVuex/src/views/tradingviewChart.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/stoneage/vueJs projects/trustLineTradeVuex/src/views/tradingviewChart.vue","mtime":1655307156181},{"path":"/home/stoneage/vueJs projects/trustLineTradeVuex/node_modules/cache-loader/dist/cjs.js","mtime":1655272566310},{"path":"/home/stoneage/vueJs projects/trustLineTradeVuex/node_modules/babel-loader/lib/index.js","mtime":1655272566942},{"path":"/home/stoneage/vueJs projects/trustLineTradeVuex/node_modules/cache-loader/dist/cjs.js","mtime":1655272566310},{"path":"/home/stoneage/vueJs projects/trustLineTradeVuex/node_modules/vue-loader/lib/index.js","mtime":1655272561270}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KCmltcG9ydCBzdG9yZSBmcm9tICIuLi9zdG9yZSI7CmltcG9ydCBjaGFydCBmcm9tICIuLi9taXhpbnMvY2hhcnRUaWNrZXIiOwppbXBvcnQgeyB3aWRnZXQgfSBmcm9tICIuLi8uLi9wdWJsaWMvY2hhcnRpbmdfbGlicmFyeSI7CmltcG9ydCBheGlvcyBmcm9tICJheGlvcyI7CmZ1bmN0aW9uIGdldExhbmd1YWdlRnJvbVVSTCgpIHsKICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoIltcXD8mXWxhbmc9KFteJiNdKikiKTsKICBjb25zdCByZXN1bHRzID0gcmVnZXguZXhlYyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTsKICByZXR1cm4gcmVzdWx0cyA9PT0gbnVsbAogICAgPyBudWxsCiAgICA6IGRlY29kZVVSSUNvbXBvbmVudChyZXN1bHRzWzFdLnJlcGxhY2UoL1wrL2csICIgIikpOwp9Ci8qIGVzbGludC1kaXNhYmxlICovCgpleHBvcnQgZGVmYXVsdCB7CiAgbmFtZTogIlRWQ2hhcnRDb250YWluZXIiLAogIHByb3BzOiB7CiAgICBzeW1ib2w6IHsKICAgICAgZGVmYXVsdDogIk5JRlRZIDUwOjpOU0U6OkluZGV4IiwKICAgICAgdHlwZTogU3RyaW5nLAogICAgfSwKICAgIGludGVydmFsOiB7CiAgICAgIGRlZmF1bHQ6ICJEIiwKICAgICAgdHlwZTogU3RyaW5nLAogICAgfSwKICAgIGNvbnRhaW5lcklkOiB7CiAgICAgIGRlZmF1bHQ6ICJ0dl9jaGFydF9jb250YWluZXIiLAogICAgICB0eXBlOiBTdHJpbmcsCiAgICB9LAogICAgZGF0YWZlZWRVcmw6IHsKICAgICAgZGVmYXVsdDoiaHR0cHM6Ly9hMy5hbGljZWJsdWVvbmxpbmUuY29tL3Jlc3QvQWxpY2VCbHVlQVBJU2VydmljZS9jaGFydCIsCiAgICAgIHR5cGU6IFN0cmluZywKICAgIH0sCiAgICBsaWJyYXJ5UGF0aDogewogICAgICBkZWZhdWx0OiAiL2NoYXJ0aW5nX2xpYnJhcnkvIiwKICAgICAgdHlwZTogU3RyaW5nLAogICAgfSwKICAgIGNoYXJ0c1N0b3JhZ2VVcmw6IHsKICAgICAgZGVmYXVsdDogImh0dHBzOi8vYTMuYWxpY2VibHVlb25saW5lLmNvbS9yZXN0L0FsaWNlQmx1ZUFQSVNlcnZpY2UiLAogICAgICB0eXBlOiBTdHJpbmcsCiAgICB9LAogICAgY2hhcnRzU3RvcmFnZUFwaVZlcnNpb246IHsKICAgICAgZGVmYXVsdDogIjEuMSIsCiAgICAgIHR5cGU6IFN0cmluZywKICAgIH0sCiAgICBjbGllbnRJZDogewogICAgICBkZWZhdWx0OiAiQUxJQ0VCTFVFIiwKICAgICAgdHlwZTogU3RyaW5nLAogICAgfSwKICAgIHVzZXJJZDogewogICAgICBkZWZhdWx0OiBzdG9yZS5zdGF0ZS5hdXRodGljYXRpb24udXNlcklkLAogICAgICB0eXBlOiBTdHJpbmcsCiAgICB9LAogICAgZnVsbHNjcmVlbjogewogICAgICBkZWZhdWx0OiBmYWxzZSwKICAgICAgdHlwZTogQm9vbGVhbiwKICAgIH0sCiAgICBhdXRvc2l6ZTogewogICAgICBkZWZhdWx0OiB0cnVlLAogICAgICB0eXBlOiBCb29sZWFuLAogICAgfSwKICAgIHN0dWRpZXNPdmVycmlkZXM6IHsKICAgICAgdHlwZTogT2JqZWN0LAogICAgfSwKICB9LAogIGRhdGEoKSB7CiAgICByZXR1cm4gewogICAgICBjdXN0b21TeW1ib2w6ICIiLAogICAgfTsKICB9LAogIGNyZWF0ZWQ6IGZ1bmN0aW9uICgpIHsKICAgIHRoaXMuJHJvb3QuJHJlZnMuVFZDaGFydENvbnRhaW5lciA9IHRoaXM7CiAgfSwKICB0dldpZGdldDogbnVsbCwKICBtb3VudGVkKCkgewogICFsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgndHJhZGluZ3ZpZXcuY2hhcnQubGFzdFVzZWRUaW1lQmFzZWRSZXNvbHV0aW9uJykgPyBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgidHJhZGluZ3ZpZXcuY2hhcnQubGFzdFVzZWRUaW1lQmFzZWRSZXNvbHV0aW9uIiwgIjFEIikgOiAnJwogICAgbGV0IHRlbXAgPXsKICAgICAgZGF0YTogImluaXRpYWwiLAogICAgICAgd2hlcmU6ICdjaGFydCcKICAgIH0KICAgIHRoaXMucmVmcmVzaCh0ZW1wKTsKICB9LAogIGRlc3Ryb3llZCgpIHsKICAgIGlmICh0aGlzLnR2V2lkZ2V0ICE9PSBudWxsKSB7CiAgICAgIHRoaXMudHZXaWRnZXQucmVtb3ZlKCk7CiAgICAgIHRoaXMudHZXaWRnZXQgPSBudWxsOwogICAgfQogIH0sCiAgbWV0aG9kczogewogICAgY3JlYXRlQ2hhcnQoZGF0YWZlZWRVcmwpIHsKICAgICAgdGhpcy5mZWVkID0gdGhpcy5jcmVhdGVGZWVkKGRhdGFmZWVkVXJsKTsKICAgIH0sCiAgICBjcmVhdGVGZWVkKGRhdGFmZWVkVXJsKSB7CiAgICAgIGxldCBEYXRhZmVlZCA9IHt9OwogICAgICBEYXRhZmVlZC5EYXRhUHVsc2VVcGRhdGVyID0gZnVuY3Rpb24gKGRhdGFmZWVkLCB1cGRhdGVGcmVxdWVuY3kpIHsKICAgICAgICB0aGlzLl9kYXRhZmVlZCA9IGRhdGFmZWVkOwogICAgICAgIHRoaXMuX3N1YnNjcmliZXJzID0ge307CiAgICAgICAgdGhpcy5fcmVxdWVzdHNQZW5kaW5nID0gMDsKICAgICAgICB2YXIgdGhhdCA9IHRoaXM7CiAgICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uICgpIHsKICAgICAgICAgIGlmICh0aGF0Ll9yZXF1ZXN0c1BlbmRpbmcgPiAwKSB7CiAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgIH0KICAgICAgICAgIGZvciAodmFyIGxpc3RlbmVyR1VJRCBpbiB0aGF0Ll9zdWJzY3JpYmVycykgewogICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uUmVjb3JkID0gdGhhdC5fc3Vic2NyaWJlcnNbbGlzdGVuZXJHVUlEXTsKICAgICAgICAgICAgdmFyIHJlc29sdXRpb24gPSBzdWJzY3JpcHRpb25SZWNvcmQucmVzb2x1dGlvbjsKICAgICAgICAgICAgdmFyIGRhdGVzUmFuZ2VSaWdodCA9IHBhcnNlSW50KAogICAgICAgICAgICAgIChuZXcgRGF0ZSgpLnZhbHVlT2YoKSAvIDEwMDApLnRvRml4ZWQoKQogICAgICAgICAgICApOwogICAgICAgICAgICAvLwlCRVdBUkU6IHBsZWFzZSBub3RlIHdlIHJlYWxseSBuZWVkIDIgYmFycywgbm90IHRoZSBvbmx5IGxhc3Qgb25lCiAgICAgICAgICAgIC8vCXNlZSB0aGUgZXhwbGFuYXRpb24gYmVsb3cuIGAxMGAgaXMgdGhlIGBsYXJnZSBlbm91Z2hgIHZhbHVlIHRvIHdvcmsgYXJvdW5kIGhvbGlkYXlzCiAgICAgICAgICAgIHZhciBkYXRlc1JhbmdlTGVmdCA9CiAgICAgICAgICAgICAgZGF0ZXNSYW5nZVJpZ2h0IC0gdGhhdC5wZXJpb2RMZW5ndGhTZWNvbmRzKHJlc29sdXRpb24sIDEwKTsKICAgICAgICAgICAgdGhhdC5fcmVxdWVzdHNQZW5kaW5nKys7CiAgICAgICAgICAgIChmdW5jdGlvbiAoX3N1YnNjcmlwdGlvblJlY29yZCkgewogICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUKICAgICAgICAgICAgICB0aGF0Ll9kYXRhZmVlZC5nZXRCYXJzKAogICAgICAgICAgICAgICAgX3N1YnNjcmlwdGlvblJlY29yZC5zeW1ib2xJbmZvLAogICAgICAgICAgICAgICAgcmVzb2x1dGlvbiwKICAgICAgICAgICAgICAgIGRhdGVzUmFuZ2VMZWZ0LAogICAgICAgICAgICAgICAgZGF0ZXNSYW5nZVJpZ2h0LAogICAgICAgICAgICAgICAgZnVuY3Rpb24gKGJhcnMpIHsKICAgICAgICAgICAgICAgICAgdGhhdC5fcmVxdWVzdHNQZW5kaW5nLS07CiAgICAgICAgICAgICAgICAgIC8vCW1lYW5zIHRoZSBzdWJzY3JpcHRpb24gd2FzIGNhbmNlbGxlZCB3aGlsZSB3YWl0aW5nIGZvciBkYXRhCiAgICAgICAgICAgICAgICAgIGlmICghdGhhdC5fc3Vic2NyaWJlcnMuaGFzT3duUHJvcGVydHkobGlzdGVuZXJHVUlEKSkgewogICAgICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICBpZiAoYmFycy5sZW5ndGggPT09IDApIHsKICAgICAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgdmFyIGxhc3RCYXIgPSBiYXJzW2JhcnMubGVuZ3RoIC0gMV07CiAgICAgICAgICAgICAgICAgIGlmICgKICAgICAgICAgICAgICAgICAgICAhaXNOYU4oX3N1YnNjcmlwdGlvblJlY29yZC5sYXN0QmFyVGltZSkgJiYKICAgICAgICAgICAgICAgICAgICBsYXN0QmFyLnRpbWUgPCBfc3Vic2NyaXB0aW9uUmVjb3JkLmxhc3RCYXJUaW1lCiAgICAgICAgICAgICAgICAgICkgewogICAgICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaWJlcnMgPSBfc3Vic2NyaXB0aW9uUmVjb3JkLmxpc3RlbmVyczsKICAgICAgICAgICAgICAgICAgLy8JQkVXQVJFOiB0aGlzIG9uZSBpc24ndCB3b3JraW5nIHdoZW4gZmlyc3QgdXBkYXRlIGNvbWVzIGFuZCB0aGlzIHVwZGF0ZSBtYWtlcyBhIG5ldyBiYXIuIEluIHRoaXMgY2FzZQogICAgICAgICAgICAgICAgICAvLwlfc3Vic2NyaXB0aW9uUmVjb3JkLmxhc3RCYXJUaW1lID0gTmFOCiAgICAgICAgICAgICAgICAgIHZhciBpc05ld0JhciA9CiAgICAgICAgICAgICAgICAgICAgIWlzTmFOKF9zdWJzY3JpcHRpb25SZWNvcmQubGFzdEJhclRpbWUpICYmCiAgICAgICAgICAgICAgICAgICAgbGFzdEJhci50aW1lID4gX3N1YnNjcmlwdGlvblJlY29yZC5sYXN0QmFyVGltZTsKICAgICAgICAgICAgICAgICAgLy8JUHVsc2UgdXBkYXRpbmcgbWF5IG1pc3Mgc29tZSB0cmFkZXMgZGF0YSAoaWUsIGlmIHB1bHNlIHBlcmlvZCA9IDEwIHNlY29kcyBhbmQgbmV3IGJhciBpcyBzdGFydGVkIDUgc2Vjb25kcyBsYXRlciBhZnRlciB0aGUgbGFzdCB1cGRhdGUsIHRoZQogICAgICAgICAgICAgICAgICAvLwlvbGQgYmFyJ3MgbGFzdCA1IHNlY29uZHMgdHJhZGVzIHdpbGwgYmUgbG9zdCkuIFRodXMsIGF0IGZpc3Qgd2Ugc2hvdWxkIGJyb2FkY2FzdCBvbGQgYmFyIHVwZGF0ZXMgd2hlbiBpdCdzIHJlYWR5LgogICAgICAgICAgICAgICAgICBpZiAoaXNOZXdCYXIpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoYmFycy5sZW5ndGggPCAyKSB7CiAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoCiAgICAgICAgICAgICAgICAgICAgICAgICJOb3QgZW5vdWdoIGJhcnMgaW4gaGlzdG9yeSBmb3IgcHJvcGVyIHB1bHNlIHVwZGF0ZS4gTmVlZCBhdCBsZWFzdCAyLiIKICAgICAgICAgICAgICAgICAgICAgICk7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgIHZhciBwcmV2aW91c0JhciA9IGJhcnNbYmFycy5sZW5ndGggLSAyXTsKICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgKytpKSB7CiAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyc1tpXShwcmV2aW91c0Jhcik7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIF9zdWJzY3JpcHRpb25SZWNvcmQubGFzdEJhclRpbWUgPSBsYXN0QmFyLnRpbWU7CiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc3Vic2NyaWJlcnMubGVuZ3RoOyArK2opIHsKICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyc1tqXShsYXN0QmFyKTsKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgIC8vCW9uIGVycm9yCiAgICAgICAgICAgICAgICBmdW5jdGlvbiAoKSB7CiAgICAgICAgICAgICAgICAgIHRoYXQuX3JlcXVlc3RzUGVuZGluZy0tOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICk7CiAgICAgICAgICAgIH0pKHN1YnNjcmlwdGlvblJlY29yZCk7CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgICBpZiAodHlwZW9mIHVwZGF0ZUZyZXF1ZW5jeSAhPSAidW5kZWZpbmVkIiAmJiB1cGRhdGVGcmVxdWVuY3kgPiAwKSB7CiAgICAgICAgICBzZXRJbnRlcnZhbCh1cGRhdGUsIHVwZGF0ZUZyZXF1ZW5jeSk7CiAgICAgICAgfQogICAgICB9OwogICAgICBEYXRhZmVlZC5EYXRhUHVsc2VVcGRhdGVyLnByb3RvdHlwZS5wZXJpb2RMZW5ndGhTZWNvbmRzID0gZnVuY3Rpb24gKAogICAgICAgIHJlc29sdXRpb24sCiAgICAgICAgcmVxdWlyZWRQZXJpb2RzQ291bnQKICAgICAgKSB7CiAgICAgICAgdmFyIGRheXNDb3VudCA9IDA7CiAgICAgICAgaWYgKHJlc29sdXRpb24gPT09ICJEIikgewogICAgICAgICAgZGF5c0NvdW50ID0gcmVxdWlyZWRQZXJpb2RzQ291bnQ7CiAgICAgICAgfSBlbHNlIGlmIChyZXNvbHV0aW9uID09PSAiTSIgfHwgcmVzb2x1dGlvbiA9PT0gIjFNIikgewogICAgICAgICAgZGF5c0NvdW50ID0gMzEgKiByZXF1aXJlZFBlcmlvZHNDb3VudDsKICAgICAgICB9IGVsc2UgaWYgKHJlc29sdXRpb24gPT09ICJXIiB8fCByZXNvbHV0aW9uID09PSAiMVciKSB7CiAgICAgICAgICBkYXlzQ291bnQgPSA3ICogcmVxdWlyZWRQZXJpb2RzQ291bnQ7CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGRheXNDb3VudCA9IChyZXF1aXJlZFBlcmlvZHNDb3VudCAqIHJlc29sdXRpb24pIC8gKDI0ICogNjApOwogICAgICAgIH0KICAgICAgICByZXR1cm4gZGF5c0NvdW50ICogMjQgKiA2MCAqIDYwOwogICAgICB9OwogICAgICBEYXRhZmVlZC5EYXRhUHVsc2VVcGRhdGVyLnByb3RvdHlwZS5zdWJzY3JpYmVEYXRhTGlzdGVuZXIgPSBmdW5jdGlvbiAoCiAgICAgICAgc3ltYm9sSW5mbywKICAgICAgICByZXNvbHV0aW9uLAogICAgICAgIG5ld0RhdGFDYWxsYmFjaywKICAgICAgICBsaXN0ZW5lckdVSUQKICAgICAgKSB7CiAgICAgICAgdGhpcy5fZGF0YWZlZWQuX2xvZ01lc3NhZ2UoIlN1YnNjcmliaW5nICIgKyBsaXN0ZW5lckdVSUQpOwogICAgICAgIGlmICghdGhpcy5fc3Vic2NyaWJlcnMuaGFzT3duUHJvcGVydHkobGlzdGVuZXJHVUlEKSkgewogICAgICAgICAgdGhpcy5fc3Vic2NyaWJlcnNbbGlzdGVuZXJHVUlEXSA9IHsKICAgICAgICAgICAgc3ltYm9sSW5mbzogc3ltYm9sSW5mbywKICAgICAgICAgICAgcmVzb2x1dGlvbjogcmVzb2x1dGlvbiwKICAgICAgICAgICAgbGFzdEJhclRpbWU6IE5hTiwKICAgICAgICAgICAgbGlzdGVuZXJzOiBbXSwKICAgICAgICAgIH07CiAgICAgICAgfQogICAgICAgIHRoaXMuX3N1YnNjcmliZXJzW2xpc3RlbmVyR1VJRF0ubGlzdGVuZXJzLnB1c2gobmV3RGF0YUNhbGxiYWNrKTsKICAgICAgfTsKICAgICAgRGF0YWZlZWQuRGF0YVB1bHNlVXBkYXRlci5wcm90b3R5cGUudW5zdWJzY3JpYmVEYXRhTGlzdGVuZXIgPSBmdW5jdGlvbiAoCiAgICAgICAgbGlzdGVuZXJHVUlECiAgICAgICkgewogICAgICAgIHRoaXMuX2RhdGFmZWVkLl9sb2dNZXNzYWdlKCJVbnN1YnNjcmliaW5nICIgKyBsaXN0ZW5lckdVSUQpOwogICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzY3JpYmVyc1tsaXN0ZW5lckdVSURdOwogICAgICB9OwogICAgICBEYXRhZmVlZC5Db250YWluZXIgPSBmdW5jdGlvbiAodXBkYXRlRnJlcXVlbmN5KSB7CiAgICAgICAgdGhpcy5fY29uZmlndXJhdGlvbiA9IHsKICAgICAgICAgIHN1cHBvcnRzX3NlYXJjaDogZmFsc2UsCiAgICAgICAgICBzdXBwb3J0c19ncm91cF9yZXF1ZXN0OiBmYWxzZSwKICAgICAgICAgIHN1cHBvcnRlZF9yZXNvbHV0aW9uczogWyIxIiwgIjUiLCAiMTUiLCAiMzAiLCAiNjAiLCAiMUQiLCAiMVciLCAiMU0iXSwKICAgICAgICAgIHN1cHBvcnRzX21hcmtzOiBmYWxzZSwKICAgICAgICAgIHN1cHBvcnRzX3RpbWVzY2FsZV9tYXJrczogZmFsc2UsCiAgICAgICAgfTsKICAgICAgICB0aGlzLl9iYXJzUHVsc2VVcGRhdGVyID0gbmV3IERhdGFmZWVkLkRhdGFQdWxzZVVwZGF0ZXIoCiAgICAgICAgICB0aGlzLAogICAgICAgICAgdXBkYXRlRnJlcXVlbmN5IHx8IDEwICogMTAwMAogICAgICAgICk7CiAgICAgICAgLy8gdGhpcy5fcXVvdGVzUHVsc2VVcGRhdGVyID0gbmV3IERhdGFmZWVkLlF1b3Rlc1B1bHNlVXBkYXRlcih0aGlzKTsKICAgICAgICB0aGlzLl9lbmFibGVMb2dnaW5nID0gdHJ1ZTsKICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTsKICAgICAgICB0aGlzLl9pbml0aWFsaXphdGlvbkZpbmlzaGVkID0gdHJ1ZTsKICAgICAgICB0aGlzLl9maXJlRXZlbnQoImluaXRpYWxpemVkIik7CiAgICAgICAgdGhpcy5fZmlyZUV2ZW50KCJjb25maWd1cmF0aW9uX3JlYWR5Iik7CiAgICAgIH07CiAgICAgIERhdGFmZWVkLkNvbnRhaW5lci5wcm90b3R5cGUuX2ZpcmVFdmVudCA9IGZ1bmN0aW9uIChldmVudCwgYXJndW1lbnQpIHsKICAgICAgICBpZiAodGhpcy5fY2FsbGJhY2tzLmhhc093blByb3BlcnR5KGV2ZW50KSkgewogICAgICAgICAgdmFyIGNhbGxiYWNrc0NoYWluID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTsKICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzQ2hhaW4ubGVuZ3RoOyArK2kpIHsKICAgICAgICAgICAgY2FsbGJhY2tzQ2hhaW5baV0oYXJndW1lbnQpOwogICAgICAgICAgfQogICAgICAgICAgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSA9IFtdOwogICAgICAgIH0KICAgICAgfTsKICAgICAgRGF0YWZlZWQuQ29udGFpbmVyLnByb3RvdHlwZS5fbG9nTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7CiAgICAgICAgaWYgKHRoaXMuX2VuYWJsZUxvZ2dpbmcpIHsKICAgICAgICAgIHZhciBub3cgPSBuZXcgRGF0ZSgpOwogICAgICAgIH0KICAgICAgfTsKICAgICAgRGF0YWZlZWQuQ29udGFpbmVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldmVudCwgY2FsbGJhY2spIHsKICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHsKICAgICAgICAgIHRoaXMuX2NhbGxiYWNrc1tldmVudF0gPSBbXTsKICAgICAgICB9CiAgICAgICAgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XS5wdXNoKGNhbGxiYWNrKTsKICAgICAgICByZXR1cm4gdGhpczsKICAgICAgfTsKICAgICAgRGF0YWZlZWQuQ29udGFpbmVyLnByb3RvdHlwZS5vblJlYWR5ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7CiAgICAgICAgbGV0IHRoYXQgPSB0aGlzOwogICAgICAgIGlmICh0aGlzLl9jb25maWd1cmF0aW9uKSB7CiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgY2FsbGJhY2sodGhhdC5fY29uZmlndXJhdGlvbik7CiAgICAgICAgICB9LCAwKTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgdGhpcy5vbigiY29uZmlndXJhdGlvbl9yZWFkeSIsIGZ1bmN0aW9uICgpIHsKICAgICAgICAgICAgY2FsbGJhY2sodGhhdC5fY29uZmlndXJhdGlvbik7CiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgIH07CiAgICAgIERhdGFmZWVkLkNvbnRhaW5lci5wcm90b3R5cGUuX3N5bWJvbFJlc29sdmVVUkwgPSAiL3N5bWJvbHMiOwogICAgICBEYXRhZmVlZC5Db250YWluZXIucHJvdG90eXBlLl9wcmV2U3ltYm9sID0gdGhpcy5jdXN0b21TeW1ib2w7CiAgICAgIERhdGFmZWVkLkNvbnRhaW5lci5wcm90b3R5cGUucmVzb2x2ZVN5bWJvbCA9IGZ1bmN0aW9uICgKICAgICAgICBzeW1ib2xOYW1lLAogICAgICAgIG9uU3ltYm9sUmVzb2x2ZWRDYWxsYmFjaywKICAgICAgICBvblJlc29sdmVFcnJvckNhbGxiYWNrCiAgICAgICkgewogICAgICAgIHRoaXMuX2xvZ01lc3NhZ2UoIkdPV05PIDo6IHJlc29sdmUgc3ltYm9sICIgKyBzeW1ib2xOYW1lKTsKICAgICAgICB0aGlzLl9sb2dNZXNzYWdlKCJHT1dOTyA6OiB0aGlzLl9wcmV2U3ltYm9sICIgKyB0aGlzLl9wcmV2U3ltYm9sKTsKICAgICAgICBpZiAoc3ltYm9sTmFtZSAmJiBzeW1ib2xOYW1lLnNwbGl0KCI6OiIpLmxlbmd0aCA8IDIpIHsKICAgICAgICAgIHN5bWJvbE5hbWUgPSB0aGlzLl9wcmV2U3ltYm9sOwogICAgICAgIH0KICAgICAgICB0aGlzLl9zZW5kKAogICAgICAgICAgZGF0YWZlZWRVcmwgKyB0aGlzLl9zeW1ib2xSZXNvbHZlVVJMLAogICAgICAgICAgewogICAgICAgICAgICBzeW1ib2w6IHN5bWJvbE5hbWUgPyBzeW1ib2xOYW1lLnRvVXBwZXJDYXNlKCkgOiAiIiwKICAgICAgICAgIH0sCiAgICAgICAgICBmdW5jdGlvbiAoZGF0YU9iaikgewogICAgICAgICAgICBkYXRhT2JqLmZ1bGxfbmFtZSA9IHN5bWJvbE5hbWU7CgogICAgICAgICAgICBvblN5bWJvbFJlc29sdmVkQ2FsbGJhY2soZGF0YU9iaik7CiAgICAgICAgICB9CiAgICAgICAgKTsKICAgICAgICB0aGlzLl9wcmV2U3ltYm9sID0gc3ltYm9sTmFtZTsKICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgiX2xhc3RCYXIiKTsKICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSgiY2hhcnRfVGlja2VyIik7CiAgICAgIH07CgogICAgICBEYXRhZmVlZC5Db250YWluZXIucHJvdG90eXBlLl9oaXN0b3J5VVJMID0gIi9oaXN0b3J5IjsKICAgICAgRGF0YWZlZWQuQ29udGFpbmVyLnByb3RvdHlwZS5nZXRCYXJzID0gZnVuY3Rpb24gKAogICAgICAgIHN5bWJvbEluZm8sCiAgICAgICAgcmVzb2x1dGlvbiwKICAgICAgICByYW5nZVN0YXJ0RGF0ZSwKICAgICAgICByYW5nZUVuZERhdGUsCiAgICAgICAgb25EYXRhQ2FsbGJhY2ssCiAgICAgICAgb25FcnJvckNhbGxiYWNrCiAgICAgICkgewogICAgICAgIHN0b3JlLmNvbW1pdCgnc2V0U3ltYm9sSW5mbycsIHN5bWJvbEluZm8pCiAgICAgICAgLy8gY2hhcnQubWV0aG9kcy5wYXNzRGF0YShzeW1ib2xJbmZvKQogICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKAogICAgICAgICAgInRyYWRpbmd2aWV3LmNoYXJ0Lmxhc3RVc2VkVGltZUJhc2VkUmVzb2x1dGlvbiIsCiAgICAgICAgICByZXNvbHV0aW9uCiAgICAgICAgKTsKICAgICAgICBpZiAocmFuZ2VTdGFydERhdGUgPiAwICYmIChyYW5nZVN0YXJ0RGF0ZSArICIiKS5sZW5ndGggPiAxMCkgewogICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFsKICAgICAgICAgICAgIkdvdCBhIEpTIHRpbWUgaW5zdGVhZCBvZiBVbml4IG9uZS4iLAogICAgICAgICAgICByYW5nZVN0YXJ0RGF0ZSwKICAgICAgICAgICAgcmFuZ2VFbmREYXRlLAogICAgICAgICAgXSk7CiAgICAgICAgfQogICAgICAgIHRoaXMuX3NlbmQoCiAgICAgICAgICBkYXRhZmVlZFVybCArIHRoaXMuX2hpc3RvcnlVUkwsCiAgICAgICAgICB7CiAgICAgICAgICAgIHN5bWJvbDogc3ltYm9sSW5mby50aWNrZXIgfHwgIiIsCiAgICAgICAgICAgIHJlc29sdXRpb246IHJlc29sdXRpb24sCiAgICAgICAgICAgIGZyb206IHJhbmdlU3RhcnREYXRlLAogICAgICAgICAgICBleGNoYW5nZTogc3ltYm9sSW5mby5leGNoYW5nZSwKICAgICAgICAgICAgdG86IHJhbmdlRW5kRGF0ZSwKICAgICAgICAgICAgdXNlcjogc3RvcmUuc3RhdGUuYXV0aHRpY2F0aW9uLnVzZXJJZCwKICAgICAgICAgIH0sCiAgICAgICAgICBmdW5jdGlvbiAoZGF0YSkgewogICAgICAgICAgICB2YXIgbm9kYXRhID0gZGF0YS5zID09PSAibm9fZGF0YSI7CiAgICAgICAgICAgIHZhciBiYXJzID0gW107CiAgICAgICAgICAgIC8vCWRhdGEgaXMgSlNPTiBoYXZpbmcgZm9ybWF0IHtzOiAic3RhdHVzIiAob2ssIG5vX2RhdGEsIGVycm9yKSwKICAgICAgICAgICAgLy8gIHY6IFt2b2x1bWVzXSwgdDogW3RpbWVzXSwgbzogW29wZW5zXSwgaDogW2hpZ2hzXSwgbDogW2xvd3NdLCBjOltjbG9zZXNdLCBuYjogIm9wdGlvbmFsX3VuaXh0aW1lX2lmX25vX2RhdGEifQogICAgICAgICAgICB2YXIgYmFyc0NvdW50ID0gbm9kYXRhID8gMCA6IGRhdGEudC5sZW5ndGg7CiAgICAgICAgICAgIHZhciB2b2x1bWVQcmVzZW50ID0gdHlwZW9mIGRhdGEudiAhPSAidW5kZWZpbmVkIjsKICAgICAgICAgICAgdmFyIG9obFByZXNlbnQgPSB0eXBlb2YgZGF0YS5vICE9ICJ1bmRlZmluZWQiOwogICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJhcnNDb3VudDsgKytpKSB7CiAgICAgICAgICAgICAgdmFyIGJhclZhbHVlID0gewogICAgICAgICAgICAgICAgdGltZTogZGF0YS50W2ldICogMTAwMCwKICAgICAgICAgICAgICAgIGNsb3NlOiBkYXRhLmNbaV0sCiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICBpZiAob2hsUHJlc2VudCkgewogICAgICAgICAgICAgICAgYmFyVmFsdWUub3BlbiA9IGRhdGEub1tpXTsKICAgICAgICAgICAgICAgIGJhclZhbHVlLmhpZ2ggPSBkYXRhLmhbaV07CiAgICAgICAgICAgICAgICBiYXJWYWx1ZS5sb3cgPSBkYXRhLmxbaV07CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGJhclZhbHVlLm9wZW4gPSBiYXJWYWx1ZS5oaWdoID0gYmFyVmFsdWUubG93ID0gYmFyVmFsdWUuY2xvc2U7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGlmICh2b2x1bWVQcmVzZW50KSB7CiAgICAgICAgICAgICAgICBiYXJWYWx1ZS52b2x1bWUgPSBkYXRhLnZbaV07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKCJfbGFzdEJhciIsIEpTT04uc3RyaW5naWZ5KGJhclZhbHVlKSk7CiAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oImxvYWRDaGFydCIsICJ0cnVlIik7CiAgICAgICAgICAgICAgYmFycy5wdXNoKGJhclZhbHVlKTsKICAgICAgICAgICAgfQogICAgICAgICAgICAvL0FQSSBjYWxsIHRvIGdldCBzY3JpcCBxdW90ZSBkYXRhCiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzeW1ib2xJbmZvKS5sZW5ndGggPiAwKSB7CgogICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCJjaGFydF9UaWNrZXIiKTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgb25EYXRhQ2FsbGJhY2soYmFycywgewogICAgICAgICAgICAgIG5vRGF0YTogbm9kYXRhLAogICAgICAgICAgICAgIG5leHRUaW1lOiBkYXRhLm5iIHx8IGRhdGEubmV4dFRpbWUsCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgICk7CiAgICAgIH07CiAgICAgIERhdGFmZWVkLkNvbnRhaW5lci5wcm90b3R5cGUuc3Vic2NyaWJlQmFycyA9IGZ1bmN0aW9uICgKICAgICAgICBzeW1ib2xJbmZvLAogICAgICAgIHJlc29sdXRpb24sCiAgICAgICAgb25SZWFsdGltZUNhbGxiYWNrLAogICAgICAgIGxpc3RlbmVyR1VJRCwKICAgICAgICBvblJlc2V0Q2FjaGVOZWVkZWRDYWxsYmFjawogICAgICApIHsKICAgICAgICBzdG9yZS5jb21taXQoInNldENoYXJ0RmVlZCIsIHsgcmVzb2x1dGlvbiwgb25SZWFsdGltZUNhbGxiYWNrIH0pOwogICAgICAgIGNoYXJ0Lm1ldGhvZHMud2ViU29ja2V0RGF0YSgiIik7CiAgICAgICAgLy8gaWYodmFsdWUgIT09ICAiaW50aWFsIiAmJiBzdG9yZS5zdGF0ZS5jaGFydEZlZWQgIT0gJycpewoKICAgICAgICAvLyAgIC8vIC8vIC8vIHRoaXMuX2JhcnNQdWxzZVVwZGF0ZXIuc3Vic2NyaWJlRGF0YUxpc3RlbmVyKHN5bWJvbEluZm8sIHJlc29sdXRpb24sIG9uUmVhbHRpbWVDYWxsYmFjaywgbGlzdGVuZXJHVUlELCBvblJlc2V0Q2FjaGVOZWVkZWRDYWxsYmFjayk7CiAgICAgIH07CiAgICAgIERhdGFmZWVkLkNvbnRhaW5lci5wcm90b3R5cGUudW5zdWJzY3JpYmVCYXJzID0gZnVuY3Rpb24gKGxpc3RlbmVyR1VJRCkgewogICAgICAgIHRoaXMuX2JhcnNQdWxzZVVwZGF0ZXIudW5zdWJzY3JpYmVEYXRhTGlzdGVuZXIobGlzdGVuZXJHVUlEKTsKICAgICAgfTsKICAgICAgRGF0YWZlZWQuQ29udGFpbmVyLnByb3RvdHlwZS5fc2VuZCA9IGZ1bmN0aW9uICh1cmwsIHBhcmFtcywgY2FsbGJhY2spIHsKICAgICAgICB2YXIgcmVxdWVzdCA9IHVybDsKICAgICAgICBpZiAocGFyYW1zKSB7CiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IE9iamVjdC5rZXlzKHBhcmFtcykubGVuZ3RoOyArK2kpIHsKICAgICAgICAgICAgdmFyIGtleSA9IE9iamVjdC5rZXlzKHBhcmFtcylbaV07CiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXNba2V5XSk7CiAgICAgICAgICAgIHJlcXVlc3QgKz0gKGkgPT09IDAgPyAiPyIgOiAiJiIpICsga2V5ICsgIj0iICsgdmFsdWU7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICAgIHRoaXMuX2xvZ01lc3NhZ2UoIk5ldyByZXF1ZXN0OiAiICsgcmVxdWVzdCk7CiAgICAgICAgYXhpb3MKICAgICAgICAgIC5nZXQocmVxdWVzdCkKICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4gewogICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZS5kYXRhKTsKICAgICAgICAgIH0pCiAgICAgICAgICAuY2F0Y2goKGVycikgPT4gewogICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpOwogICAgICAgICAgfSk7CiAgICAgIH07CiAgICAgIHJldHVybiBuZXcgRGF0YWZlZWQuQ29udGFpbmVyKCk7CiAgICB9LAogICAgcmVmcmVzaChpdGVtKSB7CiAgICAgIAogICAgICB2YXIgY3VycmVudENoYXJ0ID0gIiI7CiAgICAgIGxldCBnZXRMb2NhbCA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0oImNoYXJ0RGF0YSIpKQogICAgICBpdGVtLmRhdGEgPT0gImluaXRpYWwiCiAgICAgICAgPyAoY3VycmVudENoYXJ0ID0gZ2V0TG9jYWxbJ2RhdGEnXSkKICAgICAgICA6IChjdXJyZW50Q2hhcnQgPSBpdGVtLmRhdGEpOwogICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgiY2hhcnREYXRhIiwgSlNPTi5zdHJpbmdpZnkoZ2V0TG9jYWwpKTsKICAgICAgICBpZighY3VycmVudENoYXJ0LmNoYXJ0U3ltYm9sLmluY2x1ZGVzKCc6OklOREVYJykpewogICAgICAgIHZhciB0ZW1wID0gewogICAgICAgICAgdmFsdWU6IGN1cnJlbnRDaGFydCwKICAgICAgICAgIGZyb206IGl0ZW0ud2hlcmUsCiAgICAgICAgICBwYWdlOiAiY2hhcnQiLAogICAgICAgICAgdG9rZW46IGN1cnJlbnRDaGFydC5jaGFydFRva2VuLAogICAgICAgICAgZXhjaCA6IGN1cnJlbnRDaGFydC5jaGFydEV4Y2hhbmdlCiAgICAgICAgfTsKICAgICAgICB0aGlzLiRzdG9yZS5kaXNwYXRjaCgib3JkZXJXaW5kb3cvZ2V0U2NyaXBRdW90ZURldGFpbHMiLCB0ZW1wKTsKICAgICAgfQogdGhpcy5jdXN0b21TeW1ib2wgPSBjdXJyZW50Q2hhcnQuY2hhcnRTeW1ib2wKICAgICAgdmFyIHRlbXBEYXRhID0gewogICAgICAgIGRhdGE6IFtdLAogICAgICAgIHdoZXJlOiAiY2hhcnQiLAogICAgICAgIHN1YnNjcmliZTogY3VycmVudENoYXJ0LndlYnNvY2tldFN1YiA/IGN1cnJlbnRDaGFydC53ZWJzb2NrZXRTdWIgOiBjdXJyZW50Q2hhcnQuZXggKyAnfCcgKyBjdXJyZW50Q2hhcnQudG9rZW4gKyAnIycsCiAgICAgIH07CiAgICAgIGN1cnJlbnRDaGFydC5jaGFydCAhPSAnOjppbmRleCcgPyB0aGlzLiRzdG9yZS5kaXNwYXRjaCgid3NDb25uZWN0aW9uL3dlYnNvY2tldFN1YnNjcmlwdGlvbiIsIHRlbXBEYXRhKSA6ICcnCiAgICAgIGxldCBwcmV2UmVzb2x1dGlvbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCd0cmFkaW5ndmlldy5jaGFydC5sYXN0VXNlZFRpbWVCYXNlZFJlc29sdXRpb24nKQogICAgICBpZiAoaXRlbS5kYXRhID09ICJpbml0aWFsIikgewogICAgICB0aGlzLmNyZWF0ZUNoYXJ0KHRoaXMuZGF0YWZlZWRVcmwpOwogICAgICBjb25zdCB3aWRnZXRPcHRpb25zID0gewogICAgICAgIHN5bWJvbDogdGhpcy5jdXN0b21TeW1ib2wsCiAgICAgICAgLy8gQkVXQVJFOiBubyB0cmFpbGluZyBzbGFzaCBpcyBleHBlY3RlZCBpbiBmZWVkIFVSTAogICAgICAgIGRhdGFmZWVkOiB0aGlzLmZlZWQsCiAgICAgICAgaW50ZXJ2YWw6IHByZXZSZXNvbHV0aW9uID8gcHJldlJlc29sdXRpb24gOiB0aGlzLmludGVydmFsLAogICAgICAgIGNvbnRhaW5lcl9pZDogdGhpcy5jb250YWluZXJJZCwKICAgICAgICBsaWJyYXJ5X3BhdGg6IHRoaXMubGlicmFyeVBhdGgsCiAgICAgICAgbG9jYWxlOiBnZXRMYW5ndWFnZUZyb21VUkwoKSB8fCAiZW4iLAogICAgICAgIGRpc2FibGVkX2ZlYXR1cmVzOiBbCiAgICAgICAgICAidXNlX2xvY2Fsc3RvcmFnZV9mb3Jfc2V0dGluZ3MiLAogICAgICAgICAgImhlYWRlcl9mdWxsc2NyZWVuX2J1dHRvbiIsCiAgICAgICAgICAiaGVhZGVyX2NvbXBhcmUiLAogICAgICAgICAgImhlYWRlcl9zeW1ib2xfc2VhcmNoIgogICAgICAgIF0sCiAgICAgICAgZW5hYmxlZF9mZWF0dXJlczogWyJzdHVkeV90ZW1wbGF0ZXMiLCAiaGlkZV9sZWZ0X3Rvb2xiYXJfYnlfZGVmYXVsdCJdLAogICAgICAgIGNoYXJ0c19zdG9yYWdlX3VybDogdGhpcy5jaGFydHNTdG9yYWdlVXJsLAogICAgICAgIHVzZXJfaWQ6IHRoaXMudXNlcklkLAogICAgICAgIGZ1bGxzY3JlZW46IHRoaXMuZnVsbHNjcmVlbiwKICAgICAgICBhdXRvc2l6ZTogdGhpcy5hdXRvc2l6ZSwKICAgICAgICBzdHVkaWVzX292ZXJyaWRlczogdGhpcy5zdHVkaWVzT3ZlcnJpZGVzLAogICAgICAgIHRpbWV6b25lOiAiQXNpYS9Lb2xrYXRhIiwKICAgICAgICBjaGFydHNfc3RvcmFnZV9hcGlfdmVyc2lvbjogdGhpcy5jaGFydHNTdG9yYWdlQXBpVmVyc2lvbiwKICAgICAgICBjbGllbnRfaWQ6IHRoaXMuY2xpZW50SWQsCiAgICAgICAgYXV0b19zYXZlX2RlbGF5OiA1CiAgICAgIH07CiAgICAgIAogICAgICAgIGNvbnN0IHR2V2lkZ2V0ID0gbmV3IHdpZGdldCh3aWRnZXRPcHRpb25zKTsKICAgICAgdGhpcy50dldpZGdldCA9IHR2V2lkZ2V0OwogICAgLy8gICB0dldpZGdldC5vbkNoYXJ0UmVhZHkoZnVuY3Rpb24oKSB7CiAgICAvLyB0dldpZGdldC5vbkNvbnRleHRNZW51KGZ1bmN0aW9uKGluZGljYXRvcnMpIHsKICAgIC8vICAgICByZXR1cm4gW3sKICAgIC8vICAgICAgICAgcG9zaXRpb246ICJ0b3AiLAogICAgLy8gICAgICAgICB0ZXh0OiBpbmRpY2F0b3JzLAogICAgLy8gICAgICAgICBjbGljazogZnVuY3Rpb24oKSB7IGFsZXJ0KCJGaXJzdCBjbGlja2VkLiIpOyB9CiAgICAvLyAgICAgfSwKICAgIC8vICAgICB7IHRleHQ6ICItIiwgcG9zaXRpb246ICJ0b3AiIH0sCiAgICAvLyAgICAgeyB0ZXh0OiAiLU9iamVjdHMgVHJlZS4uLiIgfSwKICAgIC8vICAgICB7CiAgICAvLyAgICAgICAgIHBvc2l0aW9uOiAidG9wIiwKICAgIC8vICAgICAgICAgdGV4dDogIlNlY29uZCB0b3AgbWVudSBpdGVtIDIiLAogICAgLy8gICAgICAgICBjbGljazogZnVuY3Rpb24oKSB7IGFsZXJ0KCJTZWNvbmQgY2xpY2tlZC4iKTsgfQogICAgLy8gICAgIH0sIHsKICAgIC8vICAgICAgICAgcG9zaXRpb246ICJib3R0b20iLAogICAgLy8gICAgICAgICB0ZXh0OiAiQm90dG9tIG1lbnUgaXRlbSIsCiAgICAvLyAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigpIHsgYWxlcnQoIlRoaXJkIGNsaWNrZWQuIik7IH0KICAgIC8vICAgICB9XTsKICAgIC8vIH0pCiAgICAvLyAgIH0pCiAgICAgIH1lbHNlewogICAgICAgIHRoaXMudHZXaWRnZXQuc2V0U3ltYm9sKHRoaXMuY3VzdG9tU3ltYm9sLCB0aGlzLnR2V2lkZ2V0LnN5bWJvbEludGVydmFsKCkuaW50ZXJ2YWwsIGZ1bmN0aW9uKCl7fSkKICAgICAgfQogICAgfSwKICB9LAp9Owo="},{"version":3,"sources":["tradingviewChart.vue"],"names":[],"mappings":";;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"tradingviewChart.vue","sourceRoot":"src/views","sourcesContent":["<template>\n  <div class=\"TVChartContainer\" :id=\"containerId\" />\n</template>\n\n<script>\nimport store from \"../store\";\nimport chart from \"../mixins/chartTicker\";\nimport { widget } from \"../../public/charting_library\";\nimport axios from \"axios\";\nfunction getLanguageFromURL() {\n  const regex = new RegExp(\"[\\\\?&]lang=([^&#]*)\");\n  const results = regex.exec(window.location.search);\n  return results === null\n    ? null\n    : decodeURIComponent(results[1].replace(/\\+/g, \" \"));\n}\n/* eslint-disable */\n\nexport default {\n  name: \"TVChartContainer\",\n  props: {\n    symbol: {\n      default: \"NIFTY 50::NSE::Index\",\n      type: String,\n    },\n    interval: {\n      default: \"D\",\n      type: String,\n    },\n    containerId: {\n      default: \"tv_chart_container\",\n      type: String,\n    },\n    datafeedUrl: {\n      default:\"https://a3.aliceblueonline.com/rest/AliceBlueAPIService/chart\",\n      type: String,\n    },\n    libraryPath: {\n      default: \"/charting_library/\",\n      type: String,\n    },\n    chartsStorageUrl: {\n      default: \"https://a3.aliceblueonline.com/rest/AliceBlueAPIService\",\n      type: String,\n    },\n    chartsStorageApiVersion: {\n      default: \"1.1\",\n      type: String,\n    },\n    clientId: {\n      default: \"ALICEBLUE\",\n      type: String,\n    },\n    userId: {\n      default: store.state.authtication.userId,\n      type: String,\n    },\n    fullscreen: {\n      default: false,\n      type: Boolean,\n    },\n    autosize: {\n      default: true,\n      type: Boolean,\n    },\n    studiesOverrides: {\n      type: Object,\n    },\n  },\n  data() {\n    return {\n      customSymbol: \"\",\n    };\n  },\n  created: function () {\n    this.$root.$refs.TVChartContainer = this;\n  },\n  tvWidget: null,\n  mounted() {\n  !localStorage.getItem('tradingview.chart.lastUsedTimeBasedResolution') ? localStorage.setItem(\"tradingview.chart.lastUsedTimeBasedResolution\", \"1D\") : ''\n    let temp ={\n      data: \"initial\",\n       where: 'chart'\n    }\n    this.refresh(temp);\n  },\n  destroyed() {\n    if (this.tvWidget !== null) {\n      this.tvWidget.remove();\n      this.tvWidget = null;\n    }\n  },\n  methods: {\n    createChart(datafeedUrl) {\n      this.feed = this.createFeed(datafeedUrl);\n    },\n    createFeed(datafeedUrl) {\n      let Datafeed = {};\n      Datafeed.DataPulseUpdater = function (datafeed, updateFrequency) {\n        this._datafeed = datafeed;\n        this._subscribers = {};\n        this._requestsPending = 0;\n        var that = this;\n        var update = function () {\n          if (that._requestsPending > 0) {\n            return;\n          }\n          for (var listenerGUID in that._subscribers) {\n            var subscriptionRecord = that._subscribers[listenerGUID];\n            var resolution = subscriptionRecord.resolution;\n            var datesRangeRight = parseInt(\n              (new Date().valueOf() / 1000).toFixed()\n            );\n            //\tBEWARE: please note we really need 2 bars, not the only last one\n            //\tsee the explanation below. `10` is the `large enough` value to work around holidays\n            var datesRangeLeft =\n              datesRangeRight - that.periodLengthSeconds(resolution, 10);\n            that._requestsPending++;\n            (function (_subscriptionRecord) {\n              // eslint-disable-line\n              that._datafeed.getBars(\n                _subscriptionRecord.symbolInfo,\n                resolution,\n                datesRangeLeft,\n                datesRangeRight,\n                function (bars) {\n                  that._requestsPending--;\n                  //\tmeans the subscription was cancelled while waiting for data\n                  if (!that._subscribers.hasOwnProperty(listenerGUID)) {\n                    return;\n                  }\n                  if (bars.length === 0) {\n                    return;\n                  }\n                  var lastBar = bars[bars.length - 1];\n                  if (\n                    !isNaN(_subscriptionRecord.lastBarTime) &&\n                    lastBar.time < _subscriptionRecord.lastBarTime\n                  ) {\n                    return;\n                  }\n                  var subscribers = _subscriptionRecord.listeners;\n                  //\tBEWARE: this one isn't working when first update comes and this update makes a new bar. In this case\n                  //\t_subscriptionRecord.lastBarTime = NaN\n                  var isNewBar =\n                    !isNaN(_subscriptionRecord.lastBarTime) &&\n                    lastBar.time > _subscriptionRecord.lastBarTime;\n                  //\tPulse updating may miss some trades data (ie, if pulse period = 10 secods and new bar is started 5 seconds later after the last update, the\n                  //\told bar's last 5 seconds trades will be lost). Thus, at fist we should broadcast old bar updates when it's ready.\n                  if (isNewBar) {\n                    if (bars.length < 2) {\n                      throw new Error(\n                        \"Not enough bars in history for proper pulse update. Need at least 2.\"\n                      );\n                    }\n                    var previousBar = bars[bars.length - 2];\n                    for (var i = 0; i < subscribers.length; ++i) {\n                      subscribers[i](previousBar);\n                    }\n                  }\n                  _subscriptionRecord.lastBarTime = lastBar.time;\n                  for (var j = 0; j < subscribers.length; ++j) {\n                    subscribers[j](lastBar);\n                  }\n                },\n                //\ton error\n                function () {\n                  that._requestsPending--;\n                }\n              );\n            })(subscriptionRecord);\n          }\n        };\n        if (typeof updateFrequency != \"undefined\" && updateFrequency > 0) {\n          setInterval(update, updateFrequency);\n        }\n      };\n      Datafeed.DataPulseUpdater.prototype.periodLengthSeconds = function (\n        resolution,\n        requiredPeriodsCount\n      ) {\n        var daysCount = 0;\n        if (resolution === \"D\") {\n          daysCount = requiredPeriodsCount;\n        } else if (resolution === \"M\" || resolution === \"1M\") {\n          daysCount = 31 * requiredPeriodsCount;\n        } else if (resolution === \"W\" || resolution === \"1W\") {\n          daysCount = 7 * requiredPeriodsCount;\n        } else {\n          daysCount = (requiredPeriodsCount * resolution) / (24 * 60);\n        }\n        return daysCount * 24 * 60 * 60;\n      };\n      Datafeed.DataPulseUpdater.prototype.subscribeDataListener = function (\n        symbolInfo,\n        resolution,\n        newDataCallback,\n        listenerGUID\n      ) {\n        this._datafeed._logMessage(\"Subscribing \" + listenerGUID);\n        if (!this._subscribers.hasOwnProperty(listenerGUID)) {\n          this._subscribers[listenerGUID] = {\n            symbolInfo: symbolInfo,\n            resolution: resolution,\n            lastBarTime: NaN,\n            listeners: [],\n          };\n        }\n        this._subscribers[listenerGUID].listeners.push(newDataCallback);\n      };\n      Datafeed.DataPulseUpdater.prototype.unsubscribeDataListener = function (\n        listenerGUID\n      ) {\n        this._datafeed._logMessage(\"Unsubscribing \" + listenerGUID);\n        delete this._subscribers[listenerGUID];\n      };\n      Datafeed.Container = function (updateFrequency) {\n        this._configuration = {\n          supports_search: false,\n          supports_group_request: false,\n          supported_resolutions: [\"1\", \"5\", \"15\", \"30\", \"60\", \"1D\", \"1W\", \"1M\"],\n          supports_marks: false,\n          supports_timescale_marks: false,\n        };\n        this._barsPulseUpdater = new Datafeed.DataPulseUpdater(\n          this,\n          updateFrequency || 10 * 1000\n        );\n        // this._quotesPulseUpdater = new Datafeed.QuotesPulseUpdater(this);\n        this._enableLogging = true;\n        this._callbacks = {};\n        this._initializationFinished = true;\n        this._fireEvent(\"initialized\");\n        this._fireEvent(\"configuration_ready\");\n      };\n      Datafeed.Container.prototype._fireEvent = function (event, argument) {\n        if (this._callbacks.hasOwnProperty(event)) {\n          var callbacksChain = this._callbacks[event];\n          for (var i = 0; i < callbacksChain.length; ++i) {\n            callbacksChain[i](argument);\n          }\n          this._callbacks[event] = [];\n        }\n      };\n      Datafeed.Container.prototype._logMessage = function (message) {\n        if (this._enableLogging) {\n          var now = new Date();\n        }\n      };\n      Datafeed.Container.prototype.on = function (event, callback) {\n        if (!this._callbacks.hasOwnProperty(event)) {\n          this._callbacks[event] = [];\n        }\n        this._callbacks[event].push(callback);\n        return this;\n      };\n      Datafeed.Container.prototype.onReady = function (callback) {\n        let that = this;\n        if (this._configuration) {\n          setTimeout(function () {\n            callback(that._configuration);\n          }, 0);\n        } else {\n          this.on(\"configuration_ready\", function () {\n            callback(that._configuration);\n          });\n        }\n      };\n      Datafeed.Container.prototype._symbolResolveURL = \"/symbols\";\n      Datafeed.Container.prototype._prevSymbol = this.customSymbol;\n      Datafeed.Container.prototype.resolveSymbol = function (\n        symbolName,\n        onSymbolResolvedCallback,\n        onResolveErrorCallback\n      ) {\n        this._logMessage(\"GOWNO :: resolve symbol \" + symbolName);\n        this._logMessage(\"GOWNO :: this._prevSymbol \" + this._prevSymbol);\n        if (symbolName && symbolName.split(\"::\").length < 2) {\n          symbolName = this._prevSymbol;\n        }\n        this._send(\n          datafeedUrl + this._symbolResolveURL,\n          {\n            symbol: symbolName ? symbolName.toUpperCase() : \"\",\n          },\n          function (dataObj) {\n            dataObj.full_name = symbolName;\n\n            onSymbolResolvedCallback(dataObj);\n          }\n        );\n        this._prevSymbol = symbolName;\n        localStorage.removeItem(\"_lastBar\");\n        localStorage.removeItem(\"chart_Ticker\");\n      };\n\n      Datafeed.Container.prototype._historyURL = \"/history\";\n      Datafeed.Container.prototype.getBars = function (\n        symbolInfo,\n        resolution,\n        rangeStartDate,\n        rangeEndDate,\n        onDataCallback,\n        onErrorCallback\n      ) {\n        store.commit('setSymbolInfo', symbolInfo)\n        // chart.methods.passData(symbolInfo)\n        localStorage.setItem(\n          \"tradingview.chart.lastUsedTimeBasedResolution\",\n          resolution\n        );\n        if (rangeStartDate > 0 && (rangeStartDate + \"\").length > 10) {\n          throw new Error([\n            \"Got a JS time instead of Unix one.\",\n            rangeStartDate,\n            rangeEndDate,\n          ]);\n        }\n        this._send(\n          datafeedUrl + this._historyURL,\n          {\n            symbol: symbolInfo.ticker || \"\",\n            resolution: resolution,\n            from: rangeStartDate,\n            exchange: symbolInfo.exchange,\n            to: rangeEndDate,\n            user: store.state.authtication.userId,\n          },\n          function (data) {\n            var nodata = data.s === \"no_data\";\n            var bars = [];\n            //\tdata is JSON having format {s: \"status\" (ok, no_data, error),\n            //  v: [volumes], t: [times], o: [opens], h: [highs], l: [lows], c:[closes], nb: \"optional_unixtime_if_no_data\"}\n            var barsCount = nodata ? 0 : data.t.length;\n            var volumePresent = typeof data.v != \"undefined\";\n            var ohlPresent = typeof data.o != \"undefined\";\n            for (var i = 0; i < barsCount; ++i) {\n              var barValue = {\n                time: data.t[i] * 1000,\n                close: data.c[i],\n              };\n              if (ohlPresent) {\n                barValue.open = data.o[i];\n                barValue.high = data.h[i];\n                barValue.low = data.l[i];\n              } else {\n                barValue.open = barValue.high = barValue.low = barValue.close;\n              }\n              if (volumePresent) {\n                barValue.volume = data.v[i];\n              }\n              localStorage.setItem(\"_lastBar\", JSON.stringify(barValue));\n              localStorage.setItem(\"loadChart\", \"true\");\n              bars.push(barValue);\n            }\n            //API call to get scrip quote data\n            if (Object.keys(symbolInfo).length > 0) {\n\n              localStorage.removeItem(\"chart_Ticker\");\n            }\n\n            onDataCallback(bars, {\n              noData: nodata,\n              nextTime: data.nb || data.nextTime,\n            });\n          }\n        );\n      };\n      Datafeed.Container.prototype.subscribeBars = function (\n        symbolInfo,\n        resolution,\n        onRealtimeCallback,\n        listenerGUID,\n        onResetCacheNeededCallback\n      ) {\n        store.commit(\"setChartFeed\", { resolution, onRealtimeCallback });\n        chart.methods.webSocketData(\"\");\n        // if(value !==  \"intial\" && store.state.chartFeed != ''){\n\n        //   // // // this._barsPulseUpdater.subscribeDataListener(symbolInfo, resolution, onRealtimeCallback, listenerGUID, onResetCacheNeededCallback);\n      };\n      Datafeed.Container.prototype.unsubscribeBars = function (listenerGUID) {\n        this._barsPulseUpdater.unsubscribeDataListener(listenerGUID);\n      };\n      Datafeed.Container.prototype._send = function (url, params, callback) {\n        var request = url;\n        if (params) {\n          for (var i = 0; i < Object.keys(params).length; ++i) {\n            var key = Object.keys(params)[i];\n            var value = encodeURIComponent(params[key]);\n            request += (i === 0 ? \"?\" : \"&\") + key + \"=\" + value;\n          }\n        }\n        this._logMessage(\"New request: \" + request);\n        axios\n          .get(request)\n          .then((response) => {\n            callback(response.data);\n          })\n          .catch((err) => {\n            console.log(err);\n          });\n      };\n      return new Datafeed.Container();\n    },\n    refresh(item) {\n      \n      var currentChart = \"\";\n      let getLocal = JSON.parse(localStorage.getItem(\"chartData\"))\n      item.data == \"initial\"\n        ? (currentChart = getLocal['data'])\n        : (currentChart = item.data);\n      localStorage.setItem(\"chartData\", JSON.stringify(getLocal));\n        if(!currentChart.chartSymbol.includes('::INDEX')){\n        var temp = {\n          value: currentChart,\n          from: item.where,\n          page: \"chart\",\n          token: currentChart.chartToken,\n          exch : currentChart.chartExchange\n        };\n        this.$store.dispatch(\"orderWindow/getScripQuoteDetails\", temp);\n      }\n this.customSymbol = currentChart.chartSymbol\n      var tempData = {\n        data: [],\n        where: \"chart\",\n        subscribe: currentChart.websocketSub ? currentChart.websocketSub : currentChart.ex + '|' + currentChart.token + '#',\n      };\n      currentChart.chart != '::index' ? this.$store.dispatch(\"wsConnection/websocketSubscription\", tempData) : ''\n      let prevResolution = localStorage.getItem('tradingview.chart.lastUsedTimeBasedResolution')\n      if (item.data == \"initial\") {\n      this.createChart(this.datafeedUrl);\n      const widgetOptions = {\n        symbol: this.customSymbol,\n        // BEWARE: no trailing slash is expected in feed URL\n        datafeed: this.feed,\n        interval: prevResolution ? prevResolution : this.interval,\n        container_id: this.containerId,\n        library_path: this.libraryPath,\n        locale: getLanguageFromURL() || \"en\",\n        disabled_features: [\n          \"use_localstorage_for_settings\",\n          \"header_fullscreen_button\",\n          \"header_compare\",\n          \"header_symbol_search\"\n        ],\n        enabled_features: [\"study_templates\", \"hide_left_toolbar_by_default\"],\n        charts_storage_url: this.chartsStorageUrl,\n        user_id: this.userId,\n        fullscreen: this.fullscreen,\n        autosize: this.autosize,\n        studies_overrides: this.studiesOverrides,\n        timezone: \"Asia/Kolkata\",\n        charts_storage_api_version: this.chartsStorageApiVersion,\n        client_id: this.clientId,\n        auto_save_delay: 5\n      };\n      \n        const tvWidget = new widget(widgetOptions);\n      this.tvWidget = tvWidget;\n    //   tvWidget.onChartReady(function() {\n    // tvWidget.onContextMenu(function(indicators) {\n    //     return [{\n    //         position: \"top\",\n    //         text: indicators,\n    //         click: function() { alert(\"First clicked.\"); }\n    //     },\n    //     { text: \"-\", position: \"top\" },\n    //     { text: \"-Objects Tree...\" },\n    //     {\n    //         position: \"top\",\n    //         text: \"Second top menu item 2\",\n    //         click: function() { alert(\"Second clicked.\"); }\n    //     }, {\n    //         position: \"bottom\",\n    //         text: \"Bottom menu item\",\n    //         click: function() { alert(\"Third clicked.\"); }\n    //     }];\n    // })\n    //   })\n      }else{\n        this.tvWidget.setSymbol(this.customSymbol, this.tvWidget.symbolInterval().interval, function(){})\n      }\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n.TVChartContainer {\n  height: calc(100vh - 56px);\n}\n</style>"]}]}