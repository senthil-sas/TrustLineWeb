{"remainingRequest":"/home/stoneage/vueJs projects/trustLineTradeVuex/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/stoneage/vueJs projects/trustLineTradeVuex/src/views/tradingviewChart.vue?vue&type=style&index=0&id=aca5875c&lang=scss&scoped=true&","dependencies":[{"path":"/home/stoneage/vueJs projects/trustLineTradeVuex/src/views/tradingviewChart.vue","mtime":1655307156181},{"path":"/home/stoneage/vueJs projects/trustLineTradeVuex/node_modules/css-loader/dist/cjs.js","mtime":1655272566038},{"path":"/home/stoneage/vueJs projects/trustLineTradeVuex/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1655272561414},{"path":"/home/stoneage/vueJs projects/trustLineTradeVuex/node_modules/postcss-loader/src/index.js","mtime":1655272563142},{"path":"/home/stoneage/vueJs projects/trustLineTradeVuex/node_modules/sass-loader/dist/cjs.js","mtime":1655272562246},{"path":"/home/stoneage/vueJs projects/trustLineTradeVuex/node_modules/cache-loader/dist/cjs.js","mtime":1655272566310},{"path":"/home/stoneage/vueJs projects/trustLineTradeVuex/node_modules/vue-loader/lib/index.js","mtime":1655272561270}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCi5UVkNoYXJ0Q29udGFpbmVyIHsKICBoZWlnaHQ6IGNhbGMoMTAwdmggLSA1NnB4KTsKfQo="},{"version":3,"sources":["tradingviewChart.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0eA;AACA;AACA","file":"tradingviewChart.vue","sourceRoot":"src/views","sourcesContent":["<template>\n  <div class=\"TVChartContainer\" :id=\"containerId\" />\n</template>\n\n<script>\nimport store from \"../store\";\nimport chart from \"../mixins/chartTicker\";\nimport { widget } from \"../../public/charting_library\";\nimport axios from \"axios\";\nfunction getLanguageFromURL() {\n  const regex = new RegExp(\"[\\\\?&]lang=([^&#]*)\");\n  const results = regex.exec(window.location.search);\n  return results === null\n    ? null\n    : decodeURIComponent(results[1].replace(/\\+/g, \" \"));\n}\n/* eslint-disable */\n\nexport default {\n  name: \"TVChartContainer\",\n  props: {\n    symbol: {\n      default: \"NIFTY 50::NSE::Index\",\n      type: String,\n    },\n    interval: {\n      default: \"D\",\n      type: String,\n    },\n    containerId: {\n      default: \"tv_chart_container\",\n      type: String,\n    },\n    datafeedUrl: {\n      default:\"https://a3.aliceblueonline.com/rest/AliceBlueAPIService/chart\",\n      type: String,\n    },\n    libraryPath: {\n      default: \"/charting_library/\",\n      type: String,\n    },\n    chartsStorageUrl: {\n      default: \"https://a3.aliceblueonline.com/rest/AliceBlueAPIService\",\n      type: String,\n    },\n    chartsStorageApiVersion: {\n      default: \"1.1\",\n      type: String,\n    },\n    clientId: {\n      default: \"ALICEBLUE\",\n      type: String,\n    },\n    userId: {\n      default: store.state.authtication.userId,\n      type: String,\n    },\n    fullscreen: {\n      default: false,\n      type: Boolean,\n    },\n    autosize: {\n      default: true,\n      type: Boolean,\n    },\n    studiesOverrides: {\n      type: Object,\n    },\n  },\n  data() {\n    return {\n      customSymbol: \"\",\n    };\n  },\n  created: function () {\n    this.$root.$refs.TVChartContainer = this;\n  },\n  tvWidget: null,\n  mounted() {\n  !localStorage.getItem('tradingview.chart.lastUsedTimeBasedResolution') ? localStorage.setItem(\"tradingview.chart.lastUsedTimeBasedResolution\", \"1D\") : ''\n    let temp ={\n      data: \"initial\",\n       where: 'chart'\n    }\n    this.refresh(temp);\n  },\n  destroyed() {\n    if (this.tvWidget !== null) {\n      this.tvWidget.remove();\n      this.tvWidget = null;\n    }\n  },\n  methods: {\n    createChart(datafeedUrl) {\n      this.feed = this.createFeed(datafeedUrl);\n    },\n    createFeed(datafeedUrl) {\n      let Datafeed = {};\n      Datafeed.DataPulseUpdater = function (datafeed, updateFrequency) {\n        this._datafeed = datafeed;\n        this._subscribers = {};\n        this._requestsPending = 0;\n        var that = this;\n        var update = function () {\n          if (that._requestsPending > 0) {\n            return;\n          }\n          for (var listenerGUID in that._subscribers) {\n            var subscriptionRecord = that._subscribers[listenerGUID];\n            var resolution = subscriptionRecord.resolution;\n            var datesRangeRight = parseInt(\n              (new Date().valueOf() / 1000).toFixed()\n            );\n            //\tBEWARE: please note we really need 2 bars, not the only last one\n            //\tsee the explanation below. `10` is the `large enough` value to work around holidays\n            var datesRangeLeft =\n              datesRangeRight - that.periodLengthSeconds(resolution, 10);\n            that._requestsPending++;\n            (function (_subscriptionRecord) {\n              // eslint-disable-line\n              that._datafeed.getBars(\n                _subscriptionRecord.symbolInfo,\n                resolution,\n                datesRangeLeft,\n                datesRangeRight,\n                function (bars) {\n                  that._requestsPending--;\n                  //\tmeans the subscription was cancelled while waiting for data\n                  if (!that._subscribers.hasOwnProperty(listenerGUID)) {\n                    return;\n                  }\n                  if (bars.length === 0) {\n                    return;\n                  }\n                  var lastBar = bars[bars.length - 1];\n                  if (\n                    !isNaN(_subscriptionRecord.lastBarTime) &&\n                    lastBar.time < _subscriptionRecord.lastBarTime\n                  ) {\n                    return;\n                  }\n                  var subscribers = _subscriptionRecord.listeners;\n                  //\tBEWARE: this one isn't working when first update comes and this update makes a new bar. In this case\n                  //\t_subscriptionRecord.lastBarTime = NaN\n                  var isNewBar =\n                    !isNaN(_subscriptionRecord.lastBarTime) &&\n                    lastBar.time > _subscriptionRecord.lastBarTime;\n                  //\tPulse updating may miss some trades data (ie, if pulse period = 10 secods and new bar is started 5 seconds later after the last update, the\n                  //\told bar's last 5 seconds trades will be lost). Thus, at fist we should broadcast old bar updates when it's ready.\n                  if (isNewBar) {\n                    if (bars.length < 2) {\n                      throw new Error(\n                        \"Not enough bars in history for proper pulse update. Need at least 2.\"\n                      );\n                    }\n                    var previousBar = bars[bars.length - 2];\n                    for (var i = 0; i < subscribers.length; ++i) {\n                      subscribers[i](previousBar);\n                    }\n                  }\n                  _subscriptionRecord.lastBarTime = lastBar.time;\n                  for (var j = 0; j < subscribers.length; ++j) {\n                    subscribers[j](lastBar);\n                  }\n                },\n                //\ton error\n                function () {\n                  that._requestsPending--;\n                }\n              );\n            })(subscriptionRecord);\n          }\n        };\n        if (typeof updateFrequency != \"undefined\" && updateFrequency > 0) {\n          setInterval(update, updateFrequency);\n        }\n      };\n      Datafeed.DataPulseUpdater.prototype.periodLengthSeconds = function (\n        resolution,\n        requiredPeriodsCount\n      ) {\n        var daysCount = 0;\n        if (resolution === \"D\") {\n          daysCount = requiredPeriodsCount;\n        } else if (resolution === \"M\" || resolution === \"1M\") {\n          daysCount = 31 * requiredPeriodsCount;\n        } else if (resolution === \"W\" || resolution === \"1W\") {\n          daysCount = 7 * requiredPeriodsCount;\n        } else {\n          daysCount = (requiredPeriodsCount * resolution) / (24 * 60);\n        }\n        return daysCount * 24 * 60 * 60;\n      };\n      Datafeed.DataPulseUpdater.prototype.subscribeDataListener = function (\n        symbolInfo,\n        resolution,\n        newDataCallback,\n        listenerGUID\n      ) {\n        this._datafeed._logMessage(\"Subscribing \" + listenerGUID);\n        if (!this._subscribers.hasOwnProperty(listenerGUID)) {\n          this._subscribers[listenerGUID] = {\n            symbolInfo: symbolInfo,\n            resolution: resolution,\n            lastBarTime: NaN,\n            listeners: [],\n          };\n        }\n        this._subscribers[listenerGUID].listeners.push(newDataCallback);\n      };\n      Datafeed.DataPulseUpdater.prototype.unsubscribeDataListener = function (\n        listenerGUID\n      ) {\n        this._datafeed._logMessage(\"Unsubscribing \" + listenerGUID);\n        delete this._subscribers[listenerGUID];\n      };\n      Datafeed.Container = function (updateFrequency) {\n        this._configuration = {\n          supports_search: false,\n          supports_group_request: false,\n          supported_resolutions: [\"1\", \"5\", \"15\", \"30\", \"60\", \"1D\", \"1W\", \"1M\"],\n          supports_marks: false,\n          supports_timescale_marks: false,\n        };\n        this._barsPulseUpdater = new Datafeed.DataPulseUpdater(\n          this,\n          updateFrequency || 10 * 1000\n        );\n        // this._quotesPulseUpdater = new Datafeed.QuotesPulseUpdater(this);\n        this._enableLogging = true;\n        this._callbacks = {};\n        this._initializationFinished = true;\n        this._fireEvent(\"initialized\");\n        this._fireEvent(\"configuration_ready\");\n      };\n      Datafeed.Container.prototype._fireEvent = function (event, argument) {\n        if (this._callbacks.hasOwnProperty(event)) {\n          var callbacksChain = this._callbacks[event];\n          for (var i = 0; i < callbacksChain.length; ++i) {\n            callbacksChain[i](argument);\n          }\n          this._callbacks[event] = [];\n        }\n      };\n      Datafeed.Container.prototype._logMessage = function (message) {\n        if (this._enableLogging) {\n          var now = new Date();\n        }\n      };\n      Datafeed.Container.prototype.on = function (event, callback) {\n        if (!this._callbacks.hasOwnProperty(event)) {\n          this._callbacks[event] = [];\n        }\n        this._callbacks[event].push(callback);\n        return this;\n      };\n      Datafeed.Container.prototype.onReady = function (callback) {\n        let that = this;\n        if (this._configuration) {\n          setTimeout(function () {\n            callback(that._configuration);\n          }, 0);\n        } else {\n          this.on(\"configuration_ready\", function () {\n            callback(that._configuration);\n          });\n        }\n      };\n      Datafeed.Container.prototype._symbolResolveURL = \"/symbols\";\n      Datafeed.Container.prototype._prevSymbol = this.customSymbol;\n      Datafeed.Container.prototype.resolveSymbol = function (\n        symbolName,\n        onSymbolResolvedCallback,\n        onResolveErrorCallback\n      ) {\n        this._logMessage(\"GOWNO :: resolve symbol \" + symbolName);\n        this._logMessage(\"GOWNO :: this._prevSymbol \" + this._prevSymbol);\n        if (symbolName && symbolName.split(\"::\").length < 2) {\n          symbolName = this._prevSymbol;\n        }\n        this._send(\n          datafeedUrl + this._symbolResolveURL,\n          {\n            symbol: symbolName ? symbolName.toUpperCase() : \"\",\n          },\n          function (dataObj) {\n            dataObj.full_name = symbolName;\n\n            onSymbolResolvedCallback(dataObj);\n          }\n        );\n        this._prevSymbol = symbolName;\n        localStorage.removeItem(\"_lastBar\");\n        localStorage.removeItem(\"chart_Ticker\");\n      };\n\n      Datafeed.Container.prototype._historyURL = \"/history\";\n      Datafeed.Container.prototype.getBars = function (\n        symbolInfo,\n        resolution,\n        rangeStartDate,\n        rangeEndDate,\n        onDataCallback,\n        onErrorCallback\n      ) {\n        store.commit('setSymbolInfo', symbolInfo)\n        // chart.methods.passData(symbolInfo)\n        localStorage.setItem(\n          \"tradingview.chart.lastUsedTimeBasedResolution\",\n          resolution\n        );\n        if (rangeStartDate > 0 && (rangeStartDate + \"\").length > 10) {\n          throw new Error([\n            \"Got a JS time instead of Unix one.\",\n            rangeStartDate,\n            rangeEndDate,\n          ]);\n        }\n        this._send(\n          datafeedUrl + this._historyURL,\n          {\n            symbol: symbolInfo.ticker || \"\",\n            resolution: resolution,\n            from: rangeStartDate,\n            exchange: symbolInfo.exchange,\n            to: rangeEndDate,\n            user: store.state.authtication.userId,\n          },\n          function (data) {\n            var nodata = data.s === \"no_data\";\n            var bars = [];\n            //\tdata is JSON having format {s: \"status\" (ok, no_data, error),\n            //  v: [volumes], t: [times], o: [opens], h: [highs], l: [lows], c:[closes], nb: \"optional_unixtime_if_no_data\"}\n            var barsCount = nodata ? 0 : data.t.length;\n            var volumePresent = typeof data.v != \"undefined\";\n            var ohlPresent = typeof data.o != \"undefined\";\n            for (var i = 0; i < barsCount; ++i) {\n              var barValue = {\n                time: data.t[i] * 1000,\n                close: data.c[i],\n              };\n              if (ohlPresent) {\n                barValue.open = data.o[i];\n                barValue.high = data.h[i];\n                barValue.low = data.l[i];\n              } else {\n                barValue.open = barValue.high = barValue.low = barValue.close;\n              }\n              if (volumePresent) {\n                barValue.volume = data.v[i];\n              }\n              localStorage.setItem(\"_lastBar\", JSON.stringify(barValue));\n              localStorage.setItem(\"loadChart\", \"true\");\n              bars.push(barValue);\n            }\n            //API call to get scrip quote data\n            if (Object.keys(symbolInfo).length > 0) {\n\n              localStorage.removeItem(\"chart_Ticker\");\n            }\n\n            onDataCallback(bars, {\n              noData: nodata,\n              nextTime: data.nb || data.nextTime,\n            });\n          }\n        );\n      };\n      Datafeed.Container.prototype.subscribeBars = function (\n        symbolInfo,\n        resolution,\n        onRealtimeCallback,\n        listenerGUID,\n        onResetCacheNeededCallback\n      ) {\n        store.commit(\"setChartFeed\", { resolution, onRealtimeCallback });\n        chart.methods.webSocketData(\"\");\n        // if(value !==  \"intial\" && store.state.chartFeed != ''){\n\n        //   // // // this._barsPulseUpdater.subscribeDataListener(symbolInfo, resolution, onRealtimeCallback, listenerGUID, onResetCacheNeededCallback);\n      };\n      Datafeed.Container.prototype.unsubscribeBars = function (listenerGUID) {\n        this._barsPulseUpdater.unsubscribeDataListener(listenerGUID);\n      };\n      Datafeed.Container.prototype._send = function (url, params, callback) {\n        var request = url;\n        if (params) {\n          for (var i = 0; i < Object.keys(params).length; ++i) {\n            var key = Object.keys(params)[i];\n            var value = encodeURIComponent(params[key]);\n            request += (i === 0 ? \"?\" : \"&\") + key + \"=\" + value;\n          }\n        }\n        this._logMessage(\"New request: \" + request);\n        axios\n          .get(request)\n          .then((response) => {\n            callback(response.data);\n          })\n          .catch((err) => {\n            console.log(err);\n          });\n      };\n      return new Datafeed.Container();\n    },\n    refresh(item) {\n      \n      var currentChart = \"\";\n      let getLocal = JSON.parse(localStorage.getItem(\"chartData\"))\n      item.data == \"initial\"\n        ? (currentChart = getLocal['data'])\n        : (currentChart = item.data);\n      localStorage.setItem(\"chartData\", JSON.stringify(getLocal));\n        if(!currentChart.chartSymbol.includes('::INDEX')){\n        var temp = {\n          value: currentChart,\n          from: item.where,\n          page: \"chart\",\n          token: currentChart.chartToken,\n          exch : currentChart.chartExchange\n        };\n        this.$store.dispatch(\"orderWindow/getScripQuoteDetails\", temp);\n      }\n this.customSymbol = currentChart.chartSymbol\n      var tempData = {\n        data: [],\n        where: \"chart\",\n        subscribe: currentChart.websocketSub ? currentChart.websocketSub : currentChart.ex + '|' + currentChart.token + '#',\n      };\n      currentChart.chart != '::index' ? this.$store.dispatch(\"wsConnection/websocketSubscription\", tempData) : ''\n      let prevResolution = localStorage.getItem('tradingview.chart.lastUsedTimeBasedResolution')\n      if (item.data == \"initial\") {\n      this.createChart(this.datafeedUrl);\n      const widgetOptions = {\n        symbol: this.customSymbol,\n        // BEWARE: no trailing slash is expected in feed URL\n        datafeed: this.feed,\n        interval: prevResolution ? prevResolution : this.interval,\n        container_id: this.containerId,\n        library_path: this.libraryPath,\n        locale: getLanguageFromURL() || \"en\",\n        disabled_features: [\n          \"use_localstorage_for_settings\",\n          \"header_fullscreen_button\",\n          \"header_compare\",\n          \"header_symbol_search\"\n        ],\n        enabled_features: [\"study_templates\", \"hide_left_toolbar_by_default\"],\n        charts_storage_url: this.chartsStorageUrl,\n        user_id: this.userId,\n        fullscreen: this.fullscreen,\n        autosize: this.autosize,\n        studies_overrides: this.studiesOverrides,\n        timezone: \"Asia/Kolkata\",\n        charts_storage_api_version: this.chartsStorageApiVersion,\n        client_id: this.clientId,\n        auto_save_delay: 5\n      };\n      \n        const tvWidget = new widget(widgetOptions);\n      this.tvWidget = tvWidget;\n    //   tvWidget.onChartReady(function() {\n    // tvWidget.onContextMenu(function(indicators) {\n    //     return [{\n    //         position: \"top\",\n    //         text: indicators,\n    //         click: function() { alert(\"First clicked.\"); }\n    //     },\n    //     { text: \"-\", position: \"top\" },\n    //     { text: \"-Objects Tree...\" },\n    //     {\n    //         position: \"top\",\n    //         text: \"Second top menu item 2\",\n    //         click: function() { alert(\"Second clicked.\"); }\n    //     }, {\n    //         position: \"bottom\",\n    //         text: \"Bottom menu item\",\n    //         click: function() { alert(\"Third clicked.\"); }\n    //     }];\n    // })\n    //   })\n      }else{\n        this.tvWidget.setSymbol(this.customSymbol, this.tvWidget.symbolInterval().interval, function(){})\n      }\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n.TVChartContainer {\n  height: calc(100vh - 56px);\n}\n</style>"]}]}